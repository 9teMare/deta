/**
 * Encryption utilities for client-side data encryption
 * Uses Web Crypto API for AES-256-GCM encryption
 *
 * NOTE: This module requires browser environment with Web Crypto API support
 */

// Ensure we're in a browser environment
function ensureBrowser() {
    if (typeof window === "undefined") {
        throw new Error("Encryption functions can only be used in browser environment");
    }
    if (!window.crypto || !window.crypto.subtle) {
        throw new Error("Web Crypto API is not available in this environment");
    }
}

/**
 * Derives an encryption key from a user's address and optional salt
 * This creates a deterministic key that can be regenerated by the user
 * Matches backend implementation: SHA-256(address + salt)
 */
export async function deriveKeyFromAddress(address: string, salt: Uint8Array = new TextEncoder().encode("datax-salt-v1")): Promise<CryptoKey> {
    ensureBrowser();

    // Combine address and salt (matches backend DeriveKeyFromAddress)
    const encoder = new TextEncoder();
    const addressBytes = encoder.encode(address);
    const combined = new Uint8Array(addressBytes.length + salt.length);
    combined.set(addressBytes);
    combined.set(salt, addressBytes.length);

    // Hash using SHA-256 (matches backend)
    // Create a new ArrayBuffer copy to ensure type compatibility
    const combinedArray = Array.from(combined);
    const combinedBuffer = new ArrayBuffer(combinedArray.length);
    const combinedView = new Uint8Array(combinedBuffer);
    combinedView.set(combinedArray);
    const hashBuffer = await window.crypto.subtle.digest("SHA-256", combinedBuffer);
    const hashArray = new Uint8Array(hashBuffer);

    // Import the hashed key as a CryptoKey for AES-GCM
    const key = await window.crypto.subtle.importKey("raw", hashArray, { name: "AES-GCM" }, false, ["encrypt", "decrypt"]);

    return key;
}

/**
 * Encrypts data using AES-256-GCM
 * Returns: { encryptedData, nonce, metadata }
 */
export async function encryptData(data: Uint8Array, key: CryptoKey): Promise<{ encryptedData: Uint8Array; nonce: Uint8Array; metadata: string }> {
    ensureBrowser();

    // Generate a random nonce (96 bits for GCM)
    const nonce = window.crypto.getRandomValues(new Uint8Array(12));

    // Encrypt the data
    // Create a new ArrayBuffer copy to ensure type compatibility
    const dataArray = Array.from(data);
    const dataBuffer = new ArrayBuffer(dataArray.length);
    const dataView = new Uint8Array(dataBuffer);
    dataView.set(dataArray);
    const encryptedData = await window.crypto.subtle.encrypt(
        {
            name: "AES-GCM",
            iv: nonce,
            tagLength: 128, // 128-bit authentication tag
        },
        key,
        dataBuffer
    );

    // Encode nonce to base64 for storage
    const nonceBase64 = btoa(
        Array.from(nonce)
            .map((b) => String.fromCharCode(b))
            .join("")
    );

    return {
        encryptedData: new Uint8Array(encryptedData),
        nonce,
        metadata: nonceBase64,
    };
}

/**
 * Decrypts data using AES-256-GCM
 */
export async function decryptData(encryptedData: Uint8Array, key: CryptoKey, nonce: Uint8Array): Promise<Uint8Array> {
    ensureBrowser();

    // Create a new ArrayBuffer copy to ensure type compatibility
    // Copy the data to a new ArrayBuffer to avoid type issues
    const encryptedArray = Array.from(encryptedData);
    const encryptedBuffer = new ArrayBuffer(encryptedArray.length);
    const encryptedView = new Uint8Array(encryptedBuffer);
    encryptedView.set(encryptedArray);

    // Create a new ArrayBuffer for nonce to ensure type compatibility
    const nonceArray = Array.from(nonce);
    const nonceBuffer = new ArrayBuffer(nonceArray.length);
    const nonceView = new Uint8Array(nonceBuffer);
    nonceView.set(nonceArray);

    const decrypted = await window.crypto.subtle.decrypt(
        {
            name: "AES-GCM",
            iv: nonceView,
            tagLength: 128,
        },
        key,
        encryptedBuffer
    );

    return new Uint8Array(decrypted);
}

/**
 * Encrypts CSV data (as string) and returns encrypted data + metadata
 */
export async function encryptCSVData(csvData: string, address: string): Promise<{ encryptedData: Uint8Array; metadata: string }> {
    // Derive key from address
    const key = await deriveKeyFromAddress(address);

    // Convert CSV string to bytes
    const encoder = new TextEncoder();
    const data = encoder.encode(csvData);

    // Encrypt
    const { encryptedData, metadata } = await encryptData(data, key);

    return { encryptedData, metadata };
}

/**
 * Decrypts CSV data using address and metadata
 */
export async function decryptCSVData(encryptedData: Uint8Array, address: string, metadata: string): Promise<string> {
    // Derive key from address
    const key = await deriveKeyFromAddress(address);

    // Decode nonce from base64
    const nonce = Uint8Array.from(atob(metadata), (c) => c.charCodeAt(0));

    // Decrypt
    const decrypted = await decryptData(encryptedData, key, nonce);

    // Convert back to string
    const decoder = new TextDecoder();
    return decoder.decode(decrypted);
}

/**
 * Converts Uint8Array to base64 string for transmission
 */
export function uint8ArrayToBase64(data: Uint8Array): string {
    return btoa(
        Array.from(data)
            .map((b) => String.fromCharCode(b))
            .join("")
    );
}

/**
 * Converts base64 string to Uint8Array
 */
export function base64ToUint8Array(base64: string): Uint8Array {
    return Uint8Array.from(atob(base64), (c) => c.charCodeAt(0));
}
