# Security Improvements - End-to-End Encryption

## Overview
This document describes the security improvements implemented to encrypt user data before storage, ensuring that data is never stored in plaintext on S3/Supabase Storage.

## Architecture

### Client-Side Encryption
- **Location**: `frontend/lib/encryption.ts`
- **Algorithm**: AES-256-GCM
- **Key Derivation**: SHA-256(address + salt) - deterministic, can be regenerated by user
- **Process**:
  1. User uploads CSV file
  2. Frontend encrypts CSV data using Web Crypto API
  3. Encryption metadata (nonce) is base64-encoded
  4. Encrypted data and metadata are sent to backend
  5. Transaction is submitted to Aptos blockchain with encryption metadata

### Backend Encryption Service
- **Location**: `backend/services/encryption.go`
- **Features**:
  - AES-256-GCM encryption/decryption
  - Key derivation from user address
  - Encryption metadata encoding/decoding
  - Automatic encryption for legacy `StoreCSV` method

### Storage Service Updates
- **Location**: `backend/services/supabase_service.go`
- **Changes**:
  - `StoreCSV`: Now automatically encrypts data before storage
  - `StoreEncryptedCSV`: Stores pre-encrypted data (for client-side encryption)
  - `RetrieveCSV`: Automatically decrypts data on retrieval
  - `RetrieveEncryptedCSV`: Returns raw encrypted data and metadata
  - Encryption metadata stored in separate `.meta` files

### Move Contract Updates
- **Location**: `move/sources/data_registry.move`
- **Changes**:
  - Added `encryption_metadata` field to `Dataset` struct
  - Added `encryption_algorithm` field to `Dataset` struct
  - Updated `submit_data` function to accept encryption metadata
  - Updated `get_dataset` to return encryption metadata
  - Added `submit_data_legacy` for backward compatibility

## Data Flow

### Upload Flow (Encrypted)
1. User selects CSV file in frontend
2. Frontend parses CSV and generates data hash
3. Frontend encrypts CSV data using derived key from user address
4. Frontend submits transaction to Aptos with:
   - Data hash
   - Metadata (schema, description, etc.)
   - Encryption metadata (nonce)
   - Encryption algorithm identifier
5. Frontend sends encrypted data to backend via `/api/v1/data/submit-encrypted-csv`
6. Backend stores encrypted data in S3 with `.enc` extension
7. Backend stores encryption metadata in separate `.meta` file

### Retrieval Flow (Decrypted)
1. User/authorized requester requests data
2. Backend retrieves encrypted data from S3
3. Backend retrieves encryption metadata from `.meta` file
4. Backend derives decryption key from user address
5. Backend decrypts data using key and nonce
6. Backend returns decrypted CSV data

## Security Features

### Encryption at Rest
- All data stored in S3 is encrypted
- Encryption keys are derived from user addresses (deterministic)
- Nonces are randomly generated for each encryption operation
- Encryption metadata stored separately for security

### Key Management
- Keys are derived deterministically from user addresses
- No keys are stored on servers
- Users can regenerate keys if needed (same address = same key)
- Salt can be updated for key rotation if needed

### Access Control
- Encryption metadata stored on-chain for verification
- Only authorized requesters can access decrypted data
- Backend validates access permissions before decryption

## Backward Compatibility

### Legacy Support
- `submit_data_legacy` function for old transactions
- Backend `RetrieveCSV` tries encrypted format first, falls back to unencrypted
- Old unencrypted data can still be retrieved

## API Endpoints

### New Endpoints
- `POST /api/v1/data/submit-encrypted-csv`: Submit pre-encrypted CSV data
  - Body: `{ account_address, data_hash, schema, encrypted_data, encryption_metadata }`

### Updated Endpoints
- `POST /api/v1/data/submit-csv`: Still works, but now encrypts data automatically
- `POST /api/v1/data/get-csv`: Automatically decrypts data on retrieval

## Future Enhancements

### Potential Improvements
1. **User-Provided Keys**: Allow users to provide their own encryption keys
2. **Key Rotation**: Support for rotating encryption keys
3. **Homomorphic Encryption**: Enable computation on encrypted data for AI models
4. **Secure Enclaves**: Use hardware security modules for key management
5. **Multi-Party Encryption**: Support for shared datasets with multiple keys

## Testing

### Encryption/Decryption Test
```typescript
// Frontend test
const data = "test,data\n1,2";
const { encryptedData, metadata } = await encryptCSVData(data, address);
const decrypted = await decryptCSVData(encryptedData, address, metadata);
// decrypted === data
```

### Backend Test
```go
// Backend test
encryptionService := NewEncryptionService()
key := DeriveKeyFromAddress("0x123...", []byte("datax-salt-v1"))
encrypted, nonce, _ := encryptionService.EncryptData([]byte("test"), key)
decrypted, _ := encryptionService.DecryptData(encrypted, key, nonce)
// decrypted == []byte("test")
```

## Security Considerations

### Current Limitations
1. **Deterministic Keys**: Keys derived from addresses are deterministic - if address is known, key can be derived
   - **Mitigation**: Salt can be updated, or users can provide additional secret
2. **Metadata Storage**: Encryption metadata stored in separate files
   - **Mitigation**: Metadata is base64-encoded nonce, not sensitive alone
3. **Key Derivation**: Simple SHA-256 hash
   - **Mitigation**: Can be upgraded to PBKDF2 or Argon2 if needed

### Best Practices
- Always use HTTPS for data transmission
- Validate access permissions before decryption
- Store encryption metadata securely
- Consider key rotation for long-term data
- Audit encryption/decryption operations

